#version 460 core
//code from https://sites.google.com/site/john87connor/indirect-rendering/4-lod-selection-on-gpu

layout (local_size_x = 1024) in;

layout(std140, binding = 0) uniform PerFrameData
{
	vec4 viewPos;
	mat4 ViewProj;
	mat4 lavaLevel;
	mat4 lightViewProj;
	mat4 viewInv;
	mat4 projInv;
	vec4 bloom;
	vec4 deltaTime;
    vec4 normalMap;
    vec4 ssao1;
    vec4 ssao2;
	vec4 frustumPlanes[6];
	vec4 frustumCorners[8];
	uint numShapesToCull;
};

/* argument type buffered in GL_DRAW_INDIRECT_BUFFER */
struct DrawElementsIndirectCommand {
    uint count;
    uint instanceCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
};

// contains for each mesh vertex offset, element  
// offset, element count and bounding sphere
struct LODProperty {
    uint BaseVertex;
    uint BaseIndex;
    uint IndexCount;
    uint _padding1;
};

uniform bool for_shadow;

struct AABB
{
	float pt[6];
};

#define rigid       0x00000001u
#define dynamic     0x00000002u
#define decoration  0x00000004u
#define lava        0x00000008u

struct Mesh {
    LODProperty LODs[8];
    AABB bounds;
    bool is_active;
    int type;
    int mesh_index;
};



// array containing instanced data
layout (std430, binding = 1) buffer InstanceBlock {
    mat4 model[];
};


// array containing indirect draw calls
layout (std430, binding = 2) buffer IndirectBlock {
    DrawElementsIndirectCommand cmds[];
};


// array containing drawables
layout (std430, binding = 3) buffer DrawablesBlock {
    uvec2 drawables[];
};


// array containing bounding spheres for each object instance
layout (std430, binding = 6) buffer MeshPropertyBlock {
    Mesh entities[];
};

#define b_min_x b.pt[0]
#define b_min_y b.pt[1]
#define b_min_z b.pt[2]
#define b_max_x b.pt[3]
#define b_max_y b.pt[4]
#define b_max_z b.pt[5]

bool is_box_in_frustum(AABB b)
{
	// rejects if box is outside a frustum plane
	for (int i = 0; i < 6; i++) {
		int r = 0;
		r += (dot(frustumPlanes[i], vec4(b_min_x, b_min_y, b_min_z, 1.0f)) < 0.0f) ? 1 : 0;
		r += (dot(frustumPlanes[i], vec4(b_max_x, b_min_y, b_min_z, 1.0f)) < 0.0f) ? 1 : 0;
		r += (dot(frustumPlanes[i], vec4(b_min_x, b_max_y, b_min_z, 1.0f)) < 0.0f) ? 1 : 0;
		r += (dot(frustumPlanes[i], vec4(b_max_x, b_max_y, b_min_z, 1.0f)) < 0.0f) ? 1 : 0;
		r += (dot(frustumPlanes[i], vec4(b_min_x, b_min_y, b_max_z, 1.0f)) < 0.0f) ? 1 : 0;
		r += (dot(frustumPlanes[i], vec4(b_max_x, b_min_y, b_max_z, 1.0f)) < 0.0f) ? 1 : 0;
		r += (dot(frustumPlanes[i], vec4(b_min_x, b_max_y, b_max_z, 1.0f)) < 0.0f) ? 1 : 0;
		r += (dot(frustumPlanes[i], vec4(b_max_x, b_max_y, b_max_z, 1.0f)) < 0.0f) ? 1 : 0;
		if (r == 8) return false;
	}

	// rejects if box is outside frustum box
	int r = 0;
	r = 0; for (int i = 0; i < 8; i++) r += ((frustumCorners[i].x > b_max_x) ? 1 : 0); if (r == 8) return false;
	r = 0; for (int i = 0; i < 8; i++) r += ((frustumCorners[i].x < b_min_x) ? 1 : 0); if (r == 8) return false;
	r = 0; for (int i = 0; i < 8; i++) r += ((frustumCorners[i].y > b_max_y) ? 1 : 0); if (r == 8) return false;
	r = 0; for (int i = 0; i < 8; i++) r += ((frustumCorners[i].y < b_min_y) ? 1 : 0); if (r == 8) return false;
	r = 0; for (int i = 0; i < 8; i++) r += ((frustumCorners[i].z > b_max_z) ? 1 : 0); if (r == 8) return false;
	r = 0; for (int i = 0; i < 8; i++) r += ((frustumCorners[i].z < b_min_z) ? 1 : 0); if (r == 8) return false;

	return true;
}

void main()
{
    // get drawable index
    uint index = gl_GlobalInvocationID.x;
    if (index >= model.length())
        return;
    if (index >= cmds.length())
        return;
    if (index >= drawables.length())
        return;


    // get mesh properties
    Mesh entity = entities[index];
    DrawElementsIndirectCommand cmd = cmds[index];

		if (for_shadow)
		{
			cmd.instanceCount = 1;
			if (!entity.is_active)
				cmd.instanceCount = 0;

			if (entity.type == dynamic || entity.type == lava)
			{
				const mat4 node_matrix = model[index];
				const int mesh_index = entity.mesh_index;
				const uint32_t material_index = meshes_[mesh_index].material_index;
				if (materials_[material_index].type == invisible)
					cmd.instanceCount_ = 0;
				cmd.baseInstance_ = material_index + (i << 16);
				queue_scene_.model_matrices[i] = node_matrix;
			}
		}else
		{
			if (state_->cull && cmd.instanceCount_ == 1)
			{
				if (!frustum_culler::is_box_in_frustum(frustum_culler::frustum_planes, frustum_culler::frustum_corners, entity.world_bounds))
					cmd.instanceCount_ = 0;
			}

			const uint32_t mesh_index = entity.mesh_index;
			uint32_t LOD = 0; // lod_system::decide_lod(meshes_[mesh_index].index_count.size(), entity.world_bounds);
			cmd.count_ = meshes_[mesh_index].index_count[LOD];
			cmd.firstIndex_ = meshes_[mesh_index].index_offset[LOD];

			frustum_culler::models_visible += cmd.instanceCount_;
		}

    // bsphere position (in view space)
    vec3 center = meshproperty.BSphere.xyz;
    float radius = meshproperty.BSphere.w;
    vec3 position = (modelview[index] * vec4(center, 1)).xyz;

    float A = 1.0f / tan(FieldOfView * AspectRatio / 2.0f);
    float B = 1.0f / tan(FieldOfView / 2.0f);

    // camera frustum face normals
    vec3 normal_L = normalize(vec3(-A, 0, 1));

    vec3 normal_R = normalize(vec3(+A, 0, 1));

    vec3 normal_T = normalize(vec3(0, +B, 1));

    vec3 normal_B = normalize(vec3(0, -B, 1));



    // distances of bounding sphere to camera frustum faces

    float distance_L = dot(position, normal_L);

    float distance_R = dot(position, normal_R);

    float distance_T = dot(position, normal_T);

    float distance_B = dot(position, normal_B);



    // cull invisible objects

    cmds[index].InstanceCount = 0;



    if (distance_L > radius)

        return;

    if (distance_R > radius)

        return;

    if (distance_T > radius)

        return;

    if (distance_B > radius)

        return;



    // get lod count

    uint lodcount = 0;

    for (uint lod = 0; lod < 4; lod++)

    {

        if (meshproperty.LODs[lod].IndexCount == 0)

            break;

        lodcount++;

    }



    if (lodcount == 0)

        return;



    // select lod

    uint lod = uint(0.2f * length(position) / radius);

    lod = clamp(lod, 0, lodcount - 1);



    // object is visible: set mesh LOD parameters

    cmds[index].InstanceCount = 1;

    cmds[index].BaseInstance = index;

    cmds[index].BaseVertex = meshproperty.LODs[lod].BaseVertex;

    cmds[index].FirstIndex = meshproperty.LODs[lod].BaseIndex;

    cmds[index].Count = meshproperty.LODs[lod].IndexCount;

}